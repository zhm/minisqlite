{"version":3,"sources":["../src/cursor.js"],"names":["Cursor","constructor","statement","batchOffset","batchStart","batch","index","columns","finished","needsMetadata","each","callback","next","err","values","eachBatch","nextBatch","length","error","processResult","row","process","nextTick","getResults","results","_native","hasResult","hasColumns","emptyResultSet","endOfResultSet","_database","lastError"],"mappings":"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","sourcesContent":["export default class Cursor {\n  constructor(statement) {\n    this.statement = statement;\n    this.batchOffset = 0;\n    this.batchStart = 0;\n    this.batch = [];\n    this.index = 0;\n    this.columns = null;\n    this.finished = false;\n    this.needsMetadata = true;\n  }\n\n  each(callback) {\n    this.next((err, {finished, columns, values, index, statement}) => {\n      const next = () => {\n        if (!finished) {\n          this.each(callback);\n        }\n      };\n\n      callback(err, {finished, columns, values, index, statement, next});\n    });\n  }\n\n  eachBatch(callback) {\n    this.nextBatch(() => {\n      const next = () => {\n        this.index += this.batch.length;\n\n        if (!this.finished) {\n          this.eachBatch(callback);\n        }\n      };\n\n      callback(this.error,\n               {finished: this.finished,\n                columns: this.columns,\n                values: this.batch,\n                index: this.index,\n                statement: this.statement,\n                next});\n    });\n  }\n\n  next(callback) {\n    const processResult = () => {\n      let values = null;\n\n      const batchOffset = this.batchOffset;\n\n      if (this.batch.length) {\n        const row = this.batch[this.batchOffset];\n\n        this.batchOffset += 1;\n\n        values = row ? row.values : null;\n      }\n\n      /* eslint-disable callback-return */\n      callback(this.error,\n               {finished: this.finished && this.batchOffset === this.batch.length,\n                columns: this.columns,\n                values: values,\n                index: this.batchStart + batchOffset,\n                statement: this.statement});\n      /* eslint-enable callback-return */\n    };\n\n    if (this.batchOffset < this.batch.length) {\n      if (this.batchOffset % 1000 === 0) {\n        process.nextTick(processResult);\n      } else {\n        processResult();\n      }\n    } else {\n      // we need to fetch the next batch into memory\n      this.nextBatch(processResult);\n    }\n  }\n\n  nextBatch(callback) {\n    if (this.needsMetadata) {\n      this.index = 0;\n      this.columns = null;\n    }\n\n    this.statement.getResults(this.needsMetadata, (results) => {\n      this.needsMetadata = false;\n      this.batch = results;\n      this.batchOffset = 0;\n      this.finished = this.statement._native.finished();\n\n      const hasResult = results && results.length;\n\n      const hasColumns = hasResult && results[0] && results[0].columns;\n\n      // results == [ null ]\n      const emptyResultSet = hasResult &&\n                             results[results.length - 1] == null;\n\n      // results == [ ..., {} ]\n      const endOfResultSet = hasResult &&\n                             results[results.length - 1] &&\n                             results[results.length - 1].values == null;\n\n      if (hasColumns) {\n        this.batchStart = 0;\n        this.columns = results[0].columns;\n      }\n\n      // There are several possible states here because the client supports\n      // multiple result sets in a single query and the complexity that batching adds.\n      //\n      // finished?               -> we are done, don't do anything\n      // results === []          -> it's the signal of finished result set\n      // results === [ null ]    -> a query that had no result set all (no column def, just a command like CREATE TABLE)\n      // results === [ ..., {} ] -> the end of a result set has a {} at the end, note that this is NOT the end\n      //                            of the entire cursor stream because there might be more SELECT queries in the command\n      //                            text. If there are, this section below resets the index and the metadata flag so\n      //                            that the next call to getResults will request the column metadata of the next query.\n      //                            This is important when, for example, there are 2 completely different SELECT statements\n      //                            in the command text. In that case we need to ask for metadata twice.\n      if (!this.finished && (emptyResultSet || endOfResultSet)) {\n        this.needsMetadata = true;\n      }\n\n      const error = this.statement._database.lastError;\n\n      if (error) {\n        this.error = error;\n      }\n\n      /* eslint-disable callback-return */\n      callback();\n      /* eslint-enable callback-return */\n\n      if (results) {\n        this.batchStart += results.length;\n      }\n\n      if (endOfResultSet) {\n        this.batchStart = 0;\n      }\n    });\n  }\n}\n"],"file":"cursor.js"}